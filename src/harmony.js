/** * @author Piotr Cholewczuk * @licence MIT * * Date: Jun 06 2012 * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */var Harmony = Harmony || {};(function(Harmony, window, undefined) {    var config = {        lang : 'pl',        scale : 0.75,        container : "Harmony",        width : 800,        height : 448,        clef : {            accidentals : {                max : 6            }        }    };    var style = {        font : {            scale : 0.045 * config.scale,        },        glyph : {            globalAlpha : 1,            fillStyle : "#666666",            strokeStyle : "#666666",            lineWidth : 2 * config.scale        },        line : {            globalAlpha : 1,            strokeStyle : "#666666",            lineWidth : 2 * config.scale        },        text : {            fontFamily : "Calibri",            fontSize : 24 * config.scale,            padding : 4 * config.scale,            textFill : "#666666",            fill : "#ffffff",        },        group : {            color : "#666666",            margin : 24 * config.scale,            hover : "#000000",            focus : "#ff9900",        },        score : {            x : 0,            y : 0,        },        track : {            x : 0 * config.scale,            y : 164 * config.scale,            h : 224 * config.scale        },        stave : {            size : 0 * config.scale        },        lines : {            space : 16 * config.scale        },        note : {            size : 18 * config.scale        },        clef : {            size : 72 * config.scale        },        accidental : {            size : 20 * config.scale        },        meter : {            size : 50 * config.scale        },        mark : {            size : 768 * config.scale        },        addedLine : {            size : 30 * config.scale        },        funcs : {            x : 0 * config.scale,            y : 32 * config.scale,            h : 128 * config.scale,        }    };        function _(msg) {        var label = Harmony.Msg[config.lang][msg];        return (typeof(label) === 'undefined') ? msg : label;    }        function reset() {        Harmony.Canvas.canvas.resize();        render();    }    function render() {        Harmony.Canvas.canvas.clear();        Harmony.Score.score.render(new Harmony.Pos(0, 0));        Harmony.Canvas.canvas.draw();    }        function check() {        return Harmony.Rules.check(Harmony.Score.score);    }    function message(msg) {        return '[Harmony] ' + msg;    }    function log(msg) {        console.log(message(msg));    }    function info(msg) {        console.info(message(msg));    }    function debug(msg) {        console.debug(message(msg));    }    function warn(msg) {        console.warn(message(msg));    }    function error(msg) {        console.error(message(msg));    }    function extend(that, other) {        that.prototype = new other();        that.prototype.constructor = that;    }    function equals(that, other) {        if(that === other) {            return true;        }        if(!( that instanceof Object) || !( other instanceof Object)) {            return false;        }        if(that.constructor !== other.constructor) {            return false;        }        for(var p in that) {            if(!that.hasOwnProperty(p)) {                continue;            }            if(!other.hasOwnProperty(p)) {                return false;            }            if(that[p] === other[p]) {                continue;            }            if( typeof (that[p]) !== "object" && typeof (that[p]) !== "function") {                return false;            }            if(!equals(that[p], other[p])) {                return false;            }        }        for(p in other) {            if(other.hasOwnProperty(p) && !that.hasOwnProperty(p)) {                return false;            }        }        return true;    }    function clone(that) {        var maple = new that.constructor();        for(var p in that) {            if(!that.hasOwnProperty(p)) {                continue;            }            if( typeof (that[p]) !== "object") {                maple[p] = that[p];            } else {                maple[p] = clone(that[p]);            }        }        return maple;    }    function merge(that, other) {        var merged = clone(that);        for(var p in other) {            if(!other.hasOwnProperty(p)) {                continue;            }            if( typeof (other[p]) !== "object") {                merged[p] = other[p];            } else {                merged[p] = merge(merged[p], other[p]);            }        }        return merged;    }    var Obj = function Obj() {    };    Obj.prototype.clone = function() {        return Harmony.clone(this);    };    Obj.prototype.equals = function(other) {        return Harmony.equals(this, other);    };    var Enum = function Enum(map) {        this.map = map;    };    extend(Enum, Obj);    Enum.prototype.of = function(name) {        if( typeof (this.map[name]) === 'function') {            return this.map[name]();        }        Harmony.error('Name [' + name + '] does not exist in enum.');    };    Enum.prototype.name = function(value) {        for(var name in this.map) {            if( typeof (this.map[name]) === 'function') {                if(Harmony.equals(this.map[name](), value)) {                    return name;                }            }        }        Harmony.error('Value [' + value + '] does not exist in enum.');    };    Enum.prototype.first = function() {        for(var name in this.map) {            if( typeof (this.map[name]) === 'function') {                return this.map[name]();            }        }        Harmony.error('Enum is empty.');    };    Enum.prototype.last = function() {        var _last = undefined;        for(var name in this.map) {            if( typeof (this.map[name]) === 'function') {                _last = this.map[name];            }        }        if(_last) {            return _last();        }        Harmony.error('Enum is empty.');    };    Enum.prototype.next = function(value) {        var peek = false;        for(var name in this.map) {            if( typeof (this.map[name]) === 'function') {                if(peek) {                    return this.map[name]();                }                if(Harmony.equals(this.map[name](), value)) {                    peek = true;                }            }        }        return this.last();    };    Enum.prototype.prev = function(value) {        var _prev = undefined;        for(var name in this.map) {            if( typeof (this.map[name]) === 'function') {                if(Harmony.equals(this.map[name](), value)) {                    if(_prev) {                        return _prev();                    } else {                        return value;                    }                }                _prev = this.map[name];            }        }        return first();    };    var Pos = function Pos(x, y) {        this.x = x || 0;        this.y = y || 0;    };    extend(Pos, Obj);    Pos.prototype.add = function(pos) {        this.x += pos.x;        this.y += pos.y;        return this;    };        Pos.prototype.negate = function() {        this.x *= -1;        this.y *= -1;        return this;    };    Pos.prototype.addX = function(x) {        this.x += x;        return this;    };    Pos.prototype.addY = function(y) {        this.y += y;        return this;    };    Pos.prototype.addXY = function(x, y) {        this.x += x;        this.y += y;        return this;    };        Pos.prototype.scale = function(scale) {        this.x *= scale;        this.y *= scale;        return this;    };    function isInteger(s) {        if(s === undefined) {            return false;        }        return (s.toString().search(/^-?[0-9]+$/) === 0);    }    Harmony = {        style : style,        config : config,        _ : _,        reset : reset,        render : render,        check : check,        log : log,        info : info,        warn : warn,        error : error,        extend : extend,        equals : equals,        clone : clone,        merge : merge,        Obj : Obj,        Enum : Enum,        Pos : Pos,        isInteger : isInteger    };    window.Harmony = Harmony;})(Harmony, window);