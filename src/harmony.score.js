/** * @author Piotr Cholewczuk * @licence MIT * * Date: Jun 06 2012 * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */(function(Harmony, $, undefined) {    var keys = {        shift : false,        ctrl : false    };    function keyName(keyCode) {        if(keys.shift) {            shift = 'shift+';        } else {            shift = '';        }        if(keys.ctrl) {            ctrl = 'ctrl+';        } else {            ctrl = '';        }        switch(keyCode) {            case 8 :                return ctrl + shift + 'backspace';            case 13 :                return ctrl + shift + 'enter';            case 16 :                return 'shift';            case 17 :                return 'ctrl';            case 32:                return ctrl + shift + 'space';            case 33 :                return ctrl + shift + 'pageUp';            case 34 :                return ctrl + shift + 'pageDown';            case 35 :                return ctrl + shift + 'end';            case 36 :                return ctrl + shift + 'home';            case 37 :                return ctrl + shift + 'left';            case 38 :                return ctrl + shift + 'up';            case 39 :                return ctrl + shift + 'right';            case 40 :                return ctrl + shift + 'down';            case 46 :                return ctrl + shift + 'delete';        }    };    var Pointer = function Pointer(track, voice, id, funcs) {        this.track = track;        this.voice = voice;        this.id = id;        this.funcs = funcs ? funcs : false;    };    Harmony.extend(Pointer, Harmony.Obj);    var Mark = function Mark(voice, duration, pitch, rest) {        this.parent = function() {            return voice;        };        this.duration = duration;        this.pitch = pitch || undefined;        this.rest = rest || false;    };    Harmony.extend(Mark, Harmony.Obj);    Mark.prototype.render = function(pos) {        var that = this;        var from = pos.clone();        var group;        if(this.pitch && !this.rest) {            group = Harmony.Canvas.note[that.parent().flag.name()][that.duration.name()]();        } else {            group = Harmony.Canvas.rest[that.parent().flag.name()][that.duration.name()]();        }        if(!that.rest) {            var tonic = that.parent().parent().parent().tonic;            var tones = tonic.asTones();            var tone;            for(var i = 0; i < tones.length; ++i) {                if(that.pitch.asTone().note.equals(tones[i].note)) {                    tone = tones[i];                    break;                }            }            if(!that.pitch.asTone().accidental.equals(tone.accidental)) {                group = Harmony.Canvas.merge([group, Harmony.Canvas.accidental[that.pitch.asTone().accidental.name()]()]);            }            var distance = that.parent().parent().clef.asSounds() - that.pitch.asSounds();            var addedLines = undefined;            var above = distance < -9;            var below = distance > 1;            if(above) {                addedLines = Harmony.Canvas.addedLines.up(-(distance + 8));            } else if(below) {                addedLines = Harmony.Canvas.addedLines.down(distance);            }            var y = distance * (Harmony.style.lines.space / 2);            group.move(0, y);            if(addedLines) {                addedLines.move(0, y);                Harmony.Canvas.canvas.addGroup('marks', addedLines, pos);                addedLines.moveToBottom();            }        }        Harmony.Canvas.canvas.addGroup('marks', group, pos);        var pointer = new Pointer(that.parent().parent(), that.parent(), that.parent().getMarkId(that));        var index = that.parent().getMarkId(that);        that.parent().group[index] = group;        if(Harmony.Score.score.isPointer(pointer)) {            Harmony.Score.score.setFocus(group);        }        group.setDragConstraint('vertical');        group.on("mouseover", function() {            group.draggable(true);            Harmony.Score.score.setOver(group);            Harmony.Canvas.canvas.refresh('marks');        });        group.on("mouseout", function() {            group.draggable(false);            Harmony.Score.score.setOut(group);            Harmony.Canvas.canvas.refresh('marks');        });        group.on("click", function() {            Harmony.Score.score.setFocus(group);            Harmony.Score.score.setPointer(pointer);            Harmony.Canvas.canvas.refresh('marks');        });        group.on("dblclick", function() {            Harmony.Score.score.setFocus(group);            Harmony.Score.score.setPointer(pointer);            that.rest = !that.rest;            Harmony.render();            return false;        });        if(!that.rest) {            group.on("dragstart", function() {                this.__y = this.getPosition().y;                Harmony.Score.score.setFocus(group);                Harmony.Score.score.setPointer(pointer);                Harmony.Canvas.canvas.refresh('marks');                Harmony.Canvas.canvas.refresh('marks');            });            group.on("dragend", function() {                if(this.__y) {                    var offset = this.getPosition().y - this.__y;                    var absOffset = Math.abs(offset);                    var step = Math.abs(Harmony.style.lines.space / 2);                    var y = 0;                    for(var i = 0; (i * step) <= absOffset; ++i) {                        y = (i * step);                    }                    y = offset < 0 ? (y * -1) : y;                    that.pitch.addSounds(parseInt(y / -step));                    that.pitch.normalize(that.parent().parent().parent().tonic);                    Harmony.render();                }                Harmony.Canvas.canvas.refresh('marks');            });        }        group.__onKey = function(keyCode) {            switch(keyName(keyCode)) {                case 'space' :                    that.rest = !that.rest;                    Harmony.render();                    return false;                case 'shift+right' :                    that.duration = Harmony.Music.Duration.enum.prev(that.duration);                    Harmony.render();                    return false;                case 'shift+left' :                    that.duration = Harmony.Music.Duration.enum.next(that.duration);                    Harmony.render();                    return false;                case 'shift+up':                    that.pitch.addSounds(1);                    that.pitch.normalize(that.parent().parent().parent().tonic);                    Harmony.render();                    return false;                case 'shift+down':                    that.pitch.addSounds(-1);                    that.pitch.normalize(that.parent().parent().parent().tonic);                    Harmony.render();                    return false;                case 'ctrl+up' :                    that.pitch.accidental = Harmony.Music.Accidental.enum.next(that.pitch.accidental);                    Harmony.render();                    return false;                case 'ctrl+down' :                    that.pitch.accidental = Harmony.Music.Accidental.enum.prev(that.pitch.accidental);                    Harmony.render();                    return false;            }        };        return from.addX(Harmony.style.mark.size / this.duration.divider).clone();    };    var Flag = function Flag(value) {        this.value = value;    };    Harmony.extend(Flag, Harmony.Obj);    Flag.enum = new Harmony.Enum({        up : function() {            return new Harmony.Score.Flag('up');        },        down : function() {            return new Harmony.Score.Flag('down');        }    });    Flag.prototype.name = function() {        return Harmony.Score.Flag.enum.name(this);    };    var Voice = function Voice(track, flag) {        this.parent = function() {            return track;        };        this.flag = flag;        this.marks = [];        this.group = [];    };    Harmony.extend(Voice, Harmony.Obj);    Voice.prototype.addMark = function(duration, pitch, rest, index) {        this.group = [];        var mark = new Harmony.Score.Mark(this, duration, pitch, rest);        if(index) {            this.marks.splice(index, 0, mark);        } else {            this.marks.push(mark);        }        this.focus = index;        return mark;    };    Voice.prototype.removeMark = function(index) {        this.group = [];        if(index) {            this.marks.splice(index, 1);        }    };    Voice.prototype.render = function(pos) {        var _pos = pos.clone();        for(var i = 0; i < this.marks.length; ++i) {            _pos = this.marks[i].render(_pos);        }    };    Voice.prototype.getMarkId = function(mark) {        for(var i = 0; i < this.marks.length; ++i) {            if(this.marks[i] === mark) {                return i;            }        }    };    var Track = function Track(score, clef) {        this.parent = function() {            return score;        };        this.clef = clef || Harmony.Music.Clef.enum.of('treble');        this.voices = [];        this.focus = undefined;        this.group = {            clef : undefined,            meter : undefined        };    };    Harmony.extend(Track, Harmony.Obj);    Track.prototype.addVoice = function(flag) {        var voice = new Voice(this, flag);        this.voices.push(voice);        return voice;    };    Track.prototype.render = function(pos) {        var that = this;        var from = pos.clone().addXY(Harmony.style.track.x, Harmony.style.track.y);        function clef(pos) {            var clef = Harmony.Canvas.clef[that.clef.name()]();            var accidentalCount = that.parent().tonic.accidentals();            var accidentalsSize = 0;            var accidentals;            if(accidentalCount.hash > 0) {                accidentals = Harmony.Canvas.clef.accidentals[that.clef.name()].hash(accidentalCount.hash);                accidentalsSize = accidentalCount.hash * Harmony.style.accidental.size;            } else if(accidentalCount.flat > 0) {                accidentals = Harmony.Canvas.clef.accidentals[that.clef.name()].flat(accidentalCount.flat);                accidentalsSize = accidentalCount.flat * Harmony.style.accidental.size;            }            Harmony.Canvas.moveShapes(accidentals, new Harmony.Pos(Harmony.style.clef.size, 0));            var group = Harmony.Canvas.merge([clef, accidentals]);            Harmony.Canvas.canvas.addGroup('marks', group, pos);            that.group.clef = group;            var pointer = new Pointer(that, undefined, 'clef');            if(Harmony.Score.score.isPointer(pointer)) {                Harmony.Score.score.setFocus(group);            }            group.on("mouseover", function() {                Harmony.Score.score.setOver(group);                Harmony.Canvas.canvas.refresh('marks');            });            group.on("mouseout", function() {                Harmony.Score.score.setOut(group);                Harmony.Canvas.canvas.refresh('marks');            });            group.on("click", function() {                Harmony.Score.score.setFocus(group);                Harmony.Score.score.setPointer(pointer);                Harmony.Canvas.canvas.refresh('marks');            });            group.__onKey = function(keyCode) {                switch(keyName(keyCode)) {                    case 'space' :                        that.parent().tonic = that.parent().tonic.asParallel();                        $("#HarmonyTonic").html(Harmony.Score.score.tonic._());                        return false;                    case 'shift+right' :                        if(that.parent().tonic.accidentals().hash < Harmony.config.clef.accidentals.max) {                            that.parent().tonic.circleUp();                            Harmony.render();                        }                        $("#HarmonyTonic").html(Harmony.Score.score.tonic._());                        return false;                    case 'shift+left' :                        if(that.parent().tonic.accidentals().flat < Harmony.config.clef.accidentals.max) {                            that.parent().tonic.circleDown();                            Harmony.render();                        }                        $("#HarmonyTonic").html(Harmony.Score.score.tonic._());                        return false;                    case 'shift+up' :                        that.clef = Harmony.Music.Clef.enum.prev(that.clef);                        Harmony.render();                        return false;                    case 'shift+down' :                        that.clef = Harmony.Music.Clef.enum.next(that.clef);                        Harmony.render();                        return false;                }            };            return pos.clone().addX(Harmony.style.clef.size + accidentalsSize);        };        function meter(pos) {            var group = Harmony.Canvas.meter[that.parent().meter.name()]();            that.group.meter = group;            Harmony.Canvas.canvas.addGroup('marks', group, pos);            var pointer = new Pointer(that, undefined, 'meter');            if(Harmony.Score.score.isPointer(pointer)) {                Harmony.Score.score.setFocus(group);            }            group.on("mouseover", function() {                Harmony.Score.score.setOver(group);                Harmony.Canvas.canvas.refresh('marks');            });            group.on("mouseout", function() {                Harmony.Score.score.setOut(group);                Harmony.Canvas.canvas.refresh('marks');            });            group.on("click", function() {                Harmony.Score.score.setFocus(group);                Harmony.Score.score.setPointer(pointer);                Harmony.Canvas.canvas.refresh('marks');            });            group.__onKey = function(keyCode) {                switch(keyName(keyCode)) {                    case 'shift+up' :                        that.parent().meter = Harmony.Music.Meter.enum.prev(that.parent().meter);                        Harmony.reset();                        $("#HarmonyTonic").html(Harmony.Score.score.tonic._());                        return false;                    case 'shift+down' :                        that.parent().meter = Harmony.Music.Meter.enum.next(that.parent().meter);                        Harmony.reset();                        $("#HarmonyTonic").html(Harmony.Score.score.tonic._());                        return false;                    case 'shift+right' :                        that.parent().tacts = that.parent().tacts + 1;                        Harmony.reset();                        return false;                    case 'shift+left' :                        that.parent().tacts = (that.parent().tacts - 1) || 1;                        Harmony.reset();                        return false;                }            };            return pos.clone().addX(Harmony.style.meter.size);        };        function bars(pos) {            var bar;            for(var i = 0; i < that.parent().tacts; ++i) {                var text = Harmony.Canvas.text((i + 1));                text.setScale(0.5, 0.5);                Harmony.Canvas.canvas.addGroup('lines', text, pos.clone().addY(-Harmony.style.lines.space * 6));                var last = (i === (that.parent().tacts - 1));                pos.add(that.parent().size.tacts());                if(last) {                    bar = Harmony.Canvas.bar.end();                } else {                    bar = Harmony.Canvas.bar.single();                }                Harmony.Canvas.canvas.addGroup('lines', bar, pos);            }            return pos.clone();        };        function lines(from, to) {            var size = to.x - from.x;            var lines = Harmony.Canvas.lines(size);            Harmony.Canvas.canvas.addGroup('lines', lines, from);        };        var to = clef(from);        to = meter(to);        for(var i = 0; i < this.voices.length; ++i) {            this.voices[i].render(to);        }        to = bars(to);        lines(from, to);        return pos.clone().addY(Harmony.style.track.h);    };    Track.prototype.getVoiceId = function(voice) {        for(var i = 0; i < this.voices.length; ++i) {            if(this.voices[i] === voice) {                return i;            }        }    };    var Funcs = function Funcs(score) {        this.parent = function() {            return score;        };        this.funcs = [];        this.group = [];    };    Harmony.extend(Funcs, Harmony.Obj);    Funcs.prototype.render = function(from) {        var pos = from.clone().addXY(Harmony.style.funcs.x + Harmony.style.group.margin, Harmony.style.funcs.y);        var that = this;        var count = this.parent().meter.measures * this.parent().tacts;        function func(i, from) {            if(!that.funcs[i]) {                that.funcs[i] = Harmony.Music.Func.enum.of('UN');            }            var group = Harmony.Canvas.func[that.funcs[i].name()]();            var index = i;            var pointer = new Pointer(undefined, undefined, i, true);            that.group[index] = group;            if(Harmony.Score.score.isPointer(pointer)) {                Harmony.Score.score.setFocus(group);            }            group.on("mouseover", function() {                Harmony.Score.score.setOver(group);                Harmony.Canvas.canvas.refresh('marks');            });            group.on("mouseout", function() {                Harmony.Score.score.setOut(group);                Harmony.Canvas.canvas.refresh('marks');            });            group.on("click", function() {                Harmony.Score.score.setFocus(group);                Harmony.Score.score.setPointer(pointer);                Harmony.Canvas.canvas.refresh('marks');            });            group.__onKey = function(keyCode) {                switch(keyName(keyCode)) {                    case 'ctrl+up' :                        that.funcs[i] = Harmony.Music.Func.enum.prev(that.funcs[i]);                        Harmony.reset();                        return false;                    case 'ctrl+down' :                        that.funcs[i] = Harmony.Music.Func.enum.next(that.funcs[i]);                        Harmony.reset();                        return false;                    case 'shift+up' :                        switch(that.funcs[i].type) {                            case '..' :                                break;                            case 'UN' :                                that.funcs[i] = Harmony.Music.Func.enum.of('CD');                                break;                            case 'T' :                                that.funcs[i] = Harmony.Music.Func.enum.of('UN');                                break;                            case 'S' :                                that.funcs[i] = Harmony.Music.Func.enum.of('T_1');                                break;                            case 'D' :                                that.funcs[i] = Harmony.Music.Func.enum.of('S_1');                                break;                        }                        Harmony.reset();                        return false;                    case 'shift+down' :                        switch(that.funcs[i].type) {                            case '..' :                                that.funcs[i] = Harmony.Music.Func.enum.of('UN');                                break;                            case 'UN' :                                that.funcs[i] = Harmony.Music.Func.enum.of('T_1');                                break;                            case 'T' :                                that.funcs[i] = Harmony.Music.Func.enum.of('S_1');                                break;                            case 'S' :                                that.funcs[i] = Harmony.Music.Func.enum.of('D_1');                                break;                            case 'D' :                                break;                        }                        Harmony.reset();                        return false;                }            };            Harmony.Canvas.canvas.addGroup('marks', group, from.clone());            return from.clone().addX(Harmony.style.mark.size / that.parent().meter.duration.divider);        }        for(var i = 0; i < count; ++i) {            pos = func(i, pos);        }        return from.clone().addX(Harmony.style.funcs.h);    };    var Score = function Score(tonic, tacts, meter) {        var that = this;        this.tonic = tonic || new Harmony.Music.Tonic(new Harmony.Music.Tone(Harmony.Music.Note.enum.of('c'), Harmony.Music.Accidental.enum.of('natural')), Harmony.Music.Scale.enum.of('major'));        this.tacts = tacts || 1;        this.meter = meter || Harmony.Music.Meter.enum.of('4/4');        this.tracks = [];        this.funcs = new Funcs(this);        this.over = undefined;        this.focus = undefined;        this.pointer = new Pointer();        Harmony.Canvas.canvas.addLayer('lines');        Harmony.Canvas.canvas.addLayer('marks');        this.size = {            tacts : function() {                return new Harmony.Pos(that.meter.measures * (Harmony.style.mark.size / that.meter.duration.divider), 0);            },            total : function() {                return new Harmony.Pos(parseInt(Harmony.style.score.x * 2 + Harmony.style.track.x * 2 + //                that.size.tacts().x * that.tacts + //                Harmony.style.clef.size + //                Harmony.style.accidental.size * Harmony.config.clef.accidentals.max + //                Harmony.style.meter.size), //                parseInt(Harmony.style.score.y * 2 + //                Harmony.style.track.h * that.tracks.length + //                Harmony.style.funcs.h));            }        };    };    Harmony.extend(Score, Harmony.Obj);    Score.prototype.isPointer = function(pointer) {        return this.pointer.equals(pointer);    };    Score.prototype.setPointer = function(pointer) {        this.pointer = pointer;    };    Score.prototype.setFocus = function(group) {        if(this.focus) {            this.focus.__focus = false;            this.focus.__fillText();        }        this.focus = group;        group.__focus = true;        group.__fillText();    };    Score.prototype.setOver = function(group) {        document.body.style.cursor = "pointer";        if(this.over) {            this.over.__hover = false;            this.over.__fillText();        }        this.over = group;        group.__hover = true;        group.__fillText();    };    Score.prototype.setOut = function(group) {        document.body.style.cursor = "default";        if(this.over) {            this.over.__hover = false;            this.over.__fillText();        }        this.over = undefined;        group.__hover = false;        group.__fillText();    };    Score.prototype.events = function() {        var that = this;        $(document).keyup(function(event) {            switch(keyName(event.which)) {                case 'ctrl' :                    keys.ctrl = false;                    return false;                case 'shift' :                    keys.shift = false;                    return false;            }        });        function insertMark(rest) {            if(!that.pointer.track) {                that.pointer.track = that.tracks[0];            }            if(!that.pointer.voice) {                that.pointer.voice = that.pointer.track.voices[0];            }            var index = 0;            var pitch = that.pointer.track.clef.pitch.clone();            if(Harmony.Score.Flag.enum.of('up').equals(that.pointer.voice.flag)) {                pitch.addSounds(2);                pitch.normalize(that.tonic);            }            if(Harmony.isInteger(that.pointer.id)) {                index = that.pointer.id + 1;                pitch = that.pointer.voice.marks[that.pointer.id].pitch.clone() || pitch;            } else {                index = that.pointer.voice.marks.length;            }            var group = that.pointer.voice.addMark(that.meter.duration.clone(), pitch, rest, index);            that.setPointer(new Pointer(that.pointer.track, that.pointer.voice, index));            Harmony.render();        };        $('#HarmonyMenuInsert').click(function() {            insertMark(false);            $(this).blur();            return false;        });        $('#HarmonyMenuTonicPlus').click(function() {            if(that.tonic.accidentals().hash < Harmony.config.clef.accidentals.max) {                that.tonic.circleUp();                Harmony.render();            }            $("#HarmonyTonic").html(Harmony.Score.score.tonic._());            $(this).blur();            return false;        });        $('#HarmonyMenuTonicMinus').click(function() {            if(that.tonic.accidentals().flat < Harmony.config.clef.accidentals.max) {                that.tonic.circleDown();                Harmony.render();            }            $("#HarmonyTonic").html(Harmony.Score.score.tonic._());            $(this).blur();            return false;        });        $('#HarmonyMenuTonicParallel').click(function() {            that.tonic = that.tonic.asParallel();            $("#HarmonyTonic").html(Harmony.Score.score.tonic._());            $(this).blur();            return false;        });        $('#HarmonyMenuMeterPlus').click(function() {            that.meter = Harmony.Music.Meter.enum.prev(that.meter);            $("#HarmonyMeter").html(Harmony.Score.score.meter._());            Harmony.reset();            $(this).blur();            return false;        });        $('#HarmonyMenuMeterMinus').click(function() {            that.meter = Harmony.Music.Meter.enum.next(that.meter);            $("#HarmonyMeter").html(Harmony.Score.score.meter._());            Harmony.reset();            $(this).blur();            return false;        });        $('#HarmonyMenuTactsPlus').click(function() {            that.tacts = that.tacts + 1;            $("#HarmonyTacts").html(Harmony.Score.score.tacts);            Harmony.reset();            $(this).blur();            return false;        });        $('#HarmonyMenuTactsMinus').click(function() {            that.tacts = (that.tacts - 1) || 1;            $("#HarmonyTacts").html(Harmony.Score.score.tacts);            Harmony.reset();            $(this).blur();            return false;        });        $(document).keydown(function(event) {            switch(keyName(event.which)) {                case 'ctrl' :                    keys.ctrl = true;                    return false;                case 'shift' :                    keys.shift = true;                    return false;                case 'home' :                    if(that.pointer.track) {                        that.setPointer(new Pointer(that.pointer.track, that.pointer.voice, 'clef'));                        that.setFocus(that.pointer.track.group.clef);                        Harmony.Canvas.canvas.refresh('marks');                        break;                    }                    return false;                case 'end' :                    if(that.pointer.track) {                        if(that.pointer.voice) {                            var index = that.pointer.voice.marks.length - 1;                            index = index >= 0 ? index : 0;                            that.setPointer(new Pointer(that.pointer.track, that.pointer.voice, index, false));                            that.setFocus(that.pointer.voice.group[index]);                            Harmony.Canvas.canvas.refresh('marks');                            break;                        } else {                            that.setPointer(new Pointer(that.pointer.track, that.pointer.voice, 'meter', false));                            that.setFocus(that.pointer.track.group.meter);                            Harmony.Canvas.canvas.refresh('marks');                            break;                        }                    }                    return false;                case 'right' :                    if(that.pointer.track) {                        if(Harmony.isInteger(that.pointer.id) && !that.pointer.funcs) {                            var index = that.pointer.id < that.pointer.voice.marks.length - 1 ? that.pointer.id + 1 : that.pointer.voice.marks.length - 1;                            that.setPointer(new Pointer(that.pointer.track, that.pointer.voice, index, false));                            that.setFocus(that.pointer.voice.group[index]);                            Harmony.Canvas.canvas.refresh('marks');                            return false;                        }                        switch(that.pointer.id) {                            case 'clef' :                                that.setPointer(new Pointer(that.pointer.track, that.pointer.voice, 'meter', false));                                that.setFocus(that.pointer.track.group.meter);                                Harmony.Canvas.canvas.refresh('marks');                                break;                            case 'meter' :                                if(that.pointer.track.voices[0].marks.length > 0) {                                    that.setPointer(new Pointer(that.pointer.track, that.pointer.track.voices[0], 0));                                    that.setFocus(that.pointer.voice.group[0]);                                    Harmony.Canvas.canvas.refresh('marks');                                }                        }                    } else if(Harmony.isInteger(that.pointer.id) && that.pointer.funcs) {                        var index = that.pointer.id < that.funcs.funcs.length - 1 ? that.pointer.id + 1 : that.that.funcs.funcs.length - 1;                        that.setPointer(new Pointer(undefined, undefined, index, true));                        that.setFocus(that.funcs.group[index]);                        Harmony.Canvas.canvas.refresh('marks');                    }                    return false;                case 'left' :                    if(that.pointer.track) {                        if(Harmony.isInteger(that.pointer.id)) {                            var index = that.pointer.id > 0 ? that.pointer.id - 1 : 'meter';                            if(Harmony.isInteger(index)) {                                that.setPointer(new Pointer(that.pointer.track, that.pointer.voice, index, false));                                that.setFocus(that.pointer.voice.group[index]);                            } else {                                that.setPointer(new Pointer(that.pointer.track, undefined, index, false));                                that.setFocus(that.pointer.track.group[index]);                            }                            Harmony.Canvas.canvas.refresh('marks');                            return false;                        }                        switch(that.pointer.id) {                            case 'meter' :                            case 'clef' :                                that.setPointer(new Pointer(that.pointer.track, that.pointer.voice, 'clef', false));                                that.setFocus(that.pointer.track.group.clef);                                Harmony.Canvas.canvas.refresh('marks');                                break;                        }                    } else if(Harmony.isInteger(that.pointer.id) && that.pointer.funcs) {                        var index = that.pointer.id > 0 ? that.pointer.id - 1 : that.pointer.id;                        that.setPointer(new Pointer(undefined, undefined, index, true));                        that.setFocus(that.funcs.group[index]);                        Harmony.Canvas.canvas.refresh('marks');                    }                    return false;                case 'up' :                    if(that.pointer.track) {                        if(!that.pointer.voice) {                            var track = that.tracks[(that.getTrackId(that.pointer.track) - 1)];                            if(track) {                                that.setPointer(new Pointer(track, undefined, that.pointer.id, false));                                that.setFocus(that.pointer.track.group[that.pointer.id]);                                Harmony.Canvas.canvas.refresh('marks');                            }                        } else {                            var voiceId = that.pointer.track.getVoiceId(that.pointer.voice);                            if(voiceId - 1 >= 0) {                                voiceId = voiceId - 1;                            } else if(that.tracks[(that.getTrackId(that.pointer.track) - 1)]) {                                that.pointer.track = that.tracks[(that.getTrackId(that.pointer.track) - 1)];                                voiceId = that.pointer.track.voices.length - 1;                            }                            var voice = that.pointer.track.voices[voiceId];                            if(that.pointer.id >= voice.marks.length) {                                that.pointer.id = voice.marks.length - 1;                            }                            that.setPointer(new Pointer(that.pointer.track, voice, that.pointer.id));                            that.setFocus(that.pointer.voice.group[that.pointer.id]);                            Harmony.Canvas.canvas.refresh('marks');                        }                    }                    return false;                case 'down' :                    if(that.pointer.track) {                        if(!that.pointer.voice) {                            var track = that.tracks[(that.getTrackId(that.pointer.track) + 1)];                            if(track) {                                that.setPointer(new Pointer(track, undefined, that.pointer.id, false));                                that.setFocus(that.pointer.track.group[that.pointer.id]);                                Harmony.Canvas.canvas.refresh('marks');                            }                        } else {                            var voiceId = that.pointer.track.getVoiceId(that.pointer.voice);                            if(voiceId + 1 < that.pointer.track.voices.length) {                                voiceId = voiceId + 1;                            } else if(that.tracks[(that.getTrackId(that.pointer.track) + 1)]) {                                that.pointer.track = that.tracks[(that.getTrackId(that.pointer.track) + 1)];                                voiceId = 0;                            }                            var voice = that.pointer.track.voices[voiceId];                            if(that.pointer.id >= voice.marks.length) {                                that.pointer.id = voice.marks.length - 1;                            }                            that.setPointer(new Pointer(that.pointer.track, voice, that.pointer.id));                            that.setFocus(that.pointer.voice.group[that.pointer.id]);                            Harmony.Canvas.canvas.refresh('marks');                        }                    }                    return false;                case 'enter' :                    return insertMark(false);                case 'shift+enter' :                    return insertMark(true);                case 'delete' :                    if(that.pointer.track && that.pointer.voice && Harmony.isInteger(that.pointer.id) && that.pointer.id > 0) {                        that.pointer.voice.removeMark(that.pointer.id);                        that.pointer.id -= 1;                    }                    Harmony.render();                    return false;                default:                    if(that.focus && that.focus.__onKey) {                        return that.focus.__onKey(event.which);                    }            }        });    };    Score.prototype.clear = function() {        this.funcs = new Funcs(this);        this.tracks = [];        this.over = undefined;        this.focus = undefined;        this.pointer = new Pointer();        var track1 = this.addTrack(Harmony.Music.Clef.enum.of('treble'));        var voice1 = track1.addVoice(Harmony.Score.Flag.enum.of('up'));        voice1.addMark(this.meter.duration.clone(), track1.clef.pitch.clone().addSounds(8).normalize(this.tonic), false);        var voice2 = track1.addVoice(Harmony.Score.Flag.enum.of('down'));        voice2.addMark(this.meter.duration.clone(), track1.clef.pitch.clone().normalize(this.tonic), false);        var track2 = this.addTrack(Harmony.Music.Clef.enum.of('bass'));        var voice3 = track2.addVoice(Harmony.Score.Flag.enum.of('up'));        voice3.addMark(this.meter.duration.clone(), track2.clef.pitch.clone().addSounds(8), false);        var voice4 = track2.addVoice(Harmony.Score.Flag.enum.of('down'));        voice4.addMark(this.meter.duration.clone(), track2.clef.pitch.clone().normalize(this.tonic), false);    };    Score.prototype.init = function() {        this.clear();        this.events();    };    Score.prototype.addTrack = function(clef) {        var track = new Harmony.Score.Track(this, clef);        this.tracks.push(track);        return track;    };    Score.prototype.getTrackId = function(track) {        for(var i = 0; i < this.tracks.length; ++i) {            if(this.tracks[i] === track) {                return i;            }        }    };    Score.prototype.render = function(pos) {        var _pos = pos.clone().addXY(Harmony.style.score.x, Harmony.style.score.y);        for(var i = 0; i < this.tracks.length; ++i) {            _pos = this.tracks[i].render(_pos);        }        this.funcs.render(_pos.clone().addXY(Harmony.style.clef.size + (Harmony.style.accidental.size * this.tonic.accidentals().count) + Harmony.style.meter.size + Harmony.style.track.x + Harmony.style.funcs.x, Harmony.style.funcs.y));    };    Score.prototype.getVoices = function() {        var voices = [];        for(var i = 0; i < this.tracks.length; ++i) {            for(var j = 0; j < this.tracks[i].voices.length; ++j) {                voices.push(this.tracks[i].voices[j]);            }        }        return voices;    };    Harmony.Score = {        score : new Score(),        Track : Track,        Voice : Voice,        Flag : Flag,        Mark : Mark    };})(Harmony, jQuery);